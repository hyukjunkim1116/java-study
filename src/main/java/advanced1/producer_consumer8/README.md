8. 생산자 소비저 문제1

8-1 생산자와 소비자 문제
```html
생산자 소비자 문제는 생산자 스레드와 소비자 스레드가 특정 자원을 함께 생산하고 소비하면서 발생하는 문제이다.
이 문제는 결국 중간에 있는 버퍼의 크기가 한정되어 있기 때문에 발생한다. 따라서 한정된 버퍼 문제라고도 한다.
생산자 스레드 먼저 실행의 경우 버퍼가 가득 차면 그만큼 소비자 스레드가 데이터를 받지 못한다
소비자 스레드 먼저 실행의 경우 소비자 스레드 전부 먼저 데이터를 받지 못한다.
해결방안은 단순하다. 스레드가 기다리면 된다.
하지만 기다리는 코드를 sleep()와 while이용해서 짜면
문제가 더 심각해진다. 임계 영역에서 락을 가지고 대기하기 때문이다.
아무일도 하지 않고 대기하는 동안 다른 스레드에게 락을 양보하면 어떨까?
Object.wait(), Object.notify()를 사용하면 다른 스레드에게 락을 양보할 수 있다.
Object.wait()는 현재 스레드가 락을 반납하고 대기한다. 이렇게 대기 상태로 전환된 스레드는 다른 스레드가 notify() 또는 notifyAll()를 호출할 때까지 대기 상태를 유지한다.
Object.notify()는 대기 중인 스레드 중 하나를 깨운다. 대기 중인 스레드가 여러개 라면 그 중 하나만 깨워지게 된다.
Object.notifyAll()은 대기 중인 모든 스레드를 깨운다.
notify()의 문제점으로는 같은 종류의 스레드를 깨울 경우 비효율적일 수 있다는 점과
어떤 스레드가 깨어날 지 알 수 없기 때문에 발생할 수 있는 스레드 기아 문제가 있다.
notifyAll()을 사용함으로써 대기 집합에 있는 모든 스레드를 한번에 다 깨울 수 있다.
```





