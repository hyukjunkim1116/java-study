9. 생산자 소비저 문제2

9-1 Lock Condition
```html
대기 영역을 분리할 수 있다. 생산자는 소비자를 깨우고 소비자는 생산자를 깨워야 효율적이다.
Object.notify()는 대기중인 스레드 중 임의의 하나를 선택해서 깨운다.
Condition.signal()은 대기중인 스레드 중 하나를 깨우며, 일반적으로 FIFO 순서로 깨운다.
락 대기 집합의 BLOCKED와 스레드 대기 집합의 WAITING은 다르다.
후자는 Object.wait()를 통한 대기 상태이다.
synchronized를 사용한 임계 영역에 들어가려면 모니터 락이 필요하다
모니터 락이 없으면 락 대기 집합에 들어가서 BLOCKED 상태로 락을 기다린다
모니터 락을 반납하면 락 대기 집합에 있는 스레드 중 하나가 락을 획득하고 BLOCKED -> RUNNABLE 상태가 된다.
wait()를 호출해서 스레드 대기 집합에 들어가기 위해서는 모니터 락이 필요하다.
스레드 대기 집합에 들어가면 모니터 락을 반납한다.
스레드가 notify()를 호출하면 스레드 대기 집합에 있는 스레드 중 하나가 스레드 대기 집합을 빠져나온다. 그리고 모니터 락 획득을 시도한다.
```

9-2 BlockingQueue
```html
자바는 생산자 소비자 문제, 또는 한정된 버퍼라고 불리는 문제를 해결하기 위해
BlockingQueue라는 인터페이스와 구현체들을 제공한다.
```





