12. 스레드 풀과 Executor 프레임워크1

12-1 스레드 직접 사용의 문제점
```html
실무에서 스레드를 직접 생성해서 사용하면 다음과 같은 문제가 있다.
1. 스레드 생성 시간으로 인한 성능 문제
스레드를 사용하려면 먼저 스레드를 생성해야 한다. 그런데 스레드는 매우 무겁다
호출 스택을 위한 메모리를 할당해야 한다.
운영체제 자원을 사용해야 한다.
운영체제의 스케쥴러를 생성해야 한다.
2. 스레드 관리 문제
서버의 CPU, 메모리 자원은 한정되어 있으므로 스레드는 무한하게 만들 수 없다.
3. Runnable 인터페이스의 불편함
Runnable 인터페이스는 반환 값이 없고 체크 예외를 던질 수 없다.

이런 문제를 해결하려면 반환 값도 받을 수 있고 예외도 좀 더 쉽게 처리할 수 있는 방법이 필요하다.
반환값 뿐만 아니라 해당 스레드에서 발생한 예외도 받을 수 있으면 더 좋을 것이다.
1번, 2번 문제를 해결하려면 스레드를 생성하고 관리하는 풀이 필요하다.
스레드를 관리하는 스레드 풀에 스레드를 미리 필요한 만큼 만들어 둔다.
스레드 풀이라는 개념을 사용하면 스레드를 재사용할 수 있고 스레드의 생성 시간을 절약할 수 있다.
직접 구현하기 어렵다. 자바가 Executor 프레임워크를 제공해서 해결한다.
Executor 프레임워크는 지금까지 우리가 배운 멀티스레드 기술의 총 집합이 들어있다.
```

12-2 Future
```html
Runnable과 달리 Callable은 반환타입이 제네릭이므로 값을 반환할 수 있다. 체크 예외가 선언되어있다.
요청 스레드가 결과를 받아야 하는 상황이라면 Callable을 사용한 방식은 Runnable을 사용하는 방식보다 훨씬 편리하다.
코드만 보면 단순한 싱글 스레드 방식으로 개발한다는 느낌이 든다.
Future<Integer> future = es.submit(new MyCallable()); // 여기는 블로킹 아님 
future.get(); // 여기서 블로킹
```

12-3 작업 컬렉션 처리
```html
ExecutorService는 여러 작업을 한 번에 편리하게 처리하는 invokeAll(), invokeAny() 기능을 제공한다
```








