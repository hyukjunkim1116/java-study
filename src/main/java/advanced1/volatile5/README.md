5. 메모리 가시성

5-1 메모리 가시성
```html
멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제를
메모리 가시성이라고 한다.
```

5-2 volatile
```html
캐시 메모리를 사용하면 CPU 처리 성능을 개선할 수 있지만
여러 스레드에서 같은 시점에 정확히 같은 데이터를 보는 것이 더 중요할 수 있다.
성능을 포기하는 대신에 값을 읽을 때와 값을 쓸 때 모두 메인 메모리에 직접 접근하면 된다.
자바에서는 이런 기능을 volatile이라는 키워드로 제공한다.
캐시 메모리를 메인 메모리에 반영하거나 메인 메모리의 변경 내역을 캐시 메모리에 다시 불러오는 것은 CPU의 설계 방식과 실행 환경에 따라 다를 수 있다.
주로 컨텍스트 스위칭이 될 때 캐시 메모리도 함께 갱신된다.
```

5-3 자바 메모리 모델
```html
JVM은 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정하며 특히 멀티 스레드
프로그래밍에서 스레드 간의 상호작용을 정의한다.
happens-before 관계는 이름 그대로 한 동작이 다른 동작보다 먼저 발생함을 보장한다.
프로그램의 순서대로 작성된 모든 명령문은 happens-before 순서로 실행된다.
volatile 변수에 대한 쓰기 작업은 해당 변수를 읽는 모든 스레드에 보이도록 한다.
한스레드에서 start()를 호출하면, 해당 스레드 내의 모든 작업은 start() 호출 이후에 실행된 작업보다 happens-before 관계가 성립한다.
한 스레드에서 Thread.join()을 호출하면 join 대상 스레드의 모든 작업은 join()이 반환된 후의 작업보다 happens-before 관계를 가진다.
한 스레드에서 Thread.interrupt()를 호출하는 작업이 인터럽트된 스레드가 인터럽트를 감지하는 시점의 작업보다 happens-before 관계가 성립한다.
객체의 생성자는 객체가 완전히 생성된 후에만 다른 스레드에 의해 참조될 수 있도록 보장한다.
한 스레드에서 synchronized 블록을 종료한 후, 그 모니터 락을 얻는 모든 스레드는 해당 블록 내의 모든 작업을 볼 수 있다.
만약 A가 B보다 happens-before 관계에 있고 B가 C보다 happens-before 관계에 있다면 A가 C보다 happens-before 관계에 있다.

스레드의 생성 종료 인터럽트 등은 스레드의 상태를 변경하기 때문에 당연 하다.
volatile 또는 스레드 동기화 기법을 사용하면 메모리 가시성의 문제가 발생하지 않는다!
```



