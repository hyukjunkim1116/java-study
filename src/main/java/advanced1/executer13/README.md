13. 스레드 풀과 Executor 프레임워크2

13-1 우아한 종료
```html
서비스를 안정적으로 문제없이 종료하는 방식을 graceful shutdown이라 한다.
ExecutorService에는 다양한 종료 메서드가 존재한다.
void shutdown() : 새로운 작업을 받지 않고, 이미 제출된 작업을 모두 완료한 후에 종료한다.
List<Runnable> shutdownNow() : 실행 중인 작업을 중단하고 대기 중인 작업을 반환하며 즉시 종료한다. 인터럽트 발생
boolean isShutdown() : 서비스가 종료되었는지 확인한다
boolean isTerminated() : 모든 작업이 완료되었는지 확인한다
boolean awaitTermination : 서비스 종료시 모든 작업이 완료될 때까지 대기한다.
close() : shutdown()과 같다고 생각
기본적으로 우아한 종료를 선택하고 종료가 되지 않으면 강제 종료를 하는 방식으로 접근하자
shutdown() -> shutdownNow()
```

13-2 스레드 풀 관리
```html
작업을 요청하면 core 사이즈 만큼 스레드를 만든다
core 사이즈를 초과하면 큐에 작업을 넣는다
큐를 초과하면 max 사이즈 만큼 스레드를 만든다. 임시로 사용되는 초과 스레드가 생성된다. (큐가 가득차서 큐에 넣을 수도 없다. 초과 스레드가 바로 수행해야 한다)
max 사이즈를 초과하면 요청을 거절한다. 예외가 발생한다.

고정 풀 전략
스레드 풀에 nThreads 만큼의 기본 스레드를 생성한다. 초과 스레드는 생성하지 않는다. 큐 사이즈에 제한이 없다.

캐시 풀 전략
기본 스레드를 사용하지 않고 60초 생존 주기를 가진 초과 스레드만 사용한다
초과 스레드의 수는 제한이 없다
큐에 작업을 저장하지 않는다.
모든 요청이 대기하지 않고 스레드가 바로바로 처리한다.
버퍼를 두지 않는 스레드간 직거래라고 생각하자
캐시 스레드 풀 전략은 스레드가 무한으로 생성될 수 있어서 시스템이 멈추는 장애가 발생할 수 있다.
```

13-3 Executor 전략 - 사용자 정의 풀 전략
```html
일반 : 고정 크기의 스레드로 서비스 운영
긴급 : 요청이 증가하면 스레드 추가 투입
거절 : 긴급 대응도 어렵다면 요청을 거절
ExecutorService es = new ThreadPoolExecutor(100, 200, 60, TimeUnit.SECONDS, new
ArrayBlockingQueue<>(1000));
: 100개의 기본 스레드를 사용한다. 추가로 긴급 대응 가능한 스레드 100개를 사용한다. 긴급스레드는 60초의 생존 주기를 가진다.
1000개의 작업이 큐에 대기할 수 있다.

큐의 사이즈를 무조건 적어주어야 한다. 적지 않으면 무한대의 사이즈로 사용하게 되는데 큐가 가득찰 수가 없다
결국 기본 스레드 100개만으로 무한대의 작업을 처리해야 한다는 문제가 발생한다.
```

13-4 Executor 예외 정책
```html
생산자 소비자 문제를 실무에서 사용할 때는 소비자가 처리할 수 없을 정도로
생산 요청이 가득 차면 어떻게 할지를 정해야 한다. 로그도 남기고 사용자에게 문제가 있다고 알리는 것도 필요하다.
이런 것들을 위해 예외 정책이 필요하다.
ThreadPoolExecutor에 작업을 요청할 때 큐도 가득차고 초과 스레드도 더는 할당할 수 없다면 작업을 거절한다.
다양한 정책이 있다.
AbortPolicy : 새로운 작업을 제출할 때 RejectedExecutionException 발생
DiscardPolicy : 새로운 작업을 조용히 버린다
CallerRunsPolicy : 새로운 작업을 제출한 스 레드가 작업 실행
-> 생산자 스레드가 소비자 대신 일을 수행하는 것도 있지만 생산자 스레드가 대신 일을 수행하므로 작업의 생산 자체가 느려진다.
덕분에 생산 속도가 빠르다면 속도를 조절할 수 있다.
사용자 정의 정책 : 개발자가 직접 정의
```

13-5 정리
```html
실무 전략 선택

고정 스레드 풀 전략 : 트래픽이 일정하고 시스템 안정성이 가장 중요
캐시 스레드 풀 전략 : 일반적인 성장하는 서비스
사용자 정의 풀 전략 : 다양한 상황에 대응

가장 좋은 최적화는 최적화하지 않는 것이다.
미래에 발생할지 안할지 모르는 일에 코드를 최적화하지 말자.
필요하면 하자. 왜냐하면 백엔드 서버 개발자가 제일 비싼 자원이니까
필요없는 일에 비싼 자원을 넣는 일이 될 수 있다!
현재 상황에 맞는 최적화를 하자!
일반적인 경우에는 안정적으로 운영하고 싶으면 고정 풀 전략, 요청을 빠르게 대응하고 싶으면
캐시 스레드 풀 전략을 사용하고 일반적인 상황을 벗어나서 서비스가 흥하면
그때 더 나은 최적화 방법을 선택하자.
백엔드 서버 개발자라면 시스템의 자원을 적절하게 활용하되 최악의 경우 적절한 거절을 통해 시스템이 다운되지 않도록 해야 한다!!
적절한 거절은 서버도 우리의 삶에도 모두 필요하다.
```








